<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Flappy Bird with Boss Fight</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Game variables
            let bird, pipes, boss, lasers, score, frames;
            let scaleFactor, baseWidth, baseHeight;
            let gameLoop;
            let lastFrameTime = 0;

            // Utility function for scaling
            function scale(value) {
                return value * scaleFactor;
            }

            // Resize function
            function resizeCanvas() {
                baseWidth = 400;
                baseHeight = 600;
                const windowRatio = window.innerWidth / window.innerHeight;
                const gameRatio = baseWidth / baseHeight;

                if (windowRatio < gameRatio) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerWidth / gameRatio;
                } else {
                    canvas.height = window.innerHeight;
                    canvas.width = window.innerHeight * gameRatio;
                }

                scaleFactor = canvas.width / baseWidth;
            }

            const SCORE_TO_BOSS = 1;

            // Bird object
            const Bird = {
                x: 50,
                y: 300,
                width: 4,
                height: 4,
                velocity: 0,
                gravity: 0.4,
                jumpStrength: -10,
                image: new Image(),

                draw() {
                    ctx.fillStyle = "blue";
                    ctx.fillRect(scale(this.x), scale(this.y), scale(this.width), scale(this.height));
                },

                update(deltaTime) {
                    this.velocity += this.gravity;
                    this.y += this.velocity;
                },

                jump() {
                    this.velocity = this.jumpStrength;
                },

                shoot() {
                    lasers.push(new Laser(this.x + this.width, this.y + this.height / 2));
                },
            };

            // Pipe object
            class Pipe {
                constructor() {
                    this.x = baseWidth;
                    this.width = 50;
                    this.topHeight = Math.random() * (baseHeight - 200) + 50;
                    this.bottomY = this.topHeight + 250;
                }
                draw() {
                    ctx.fillStyle = "green";
                    ctx.fillRect(scale(this.x), 0, scale(this.width), scale(this.topHeight));
                    ctx.fillRect(scale(this.x), scale(this.bottomY), scale(this.width), scale(baseHeight - this.bottomY));
                }

                update(deltaTime) {
                    this.x -= 150 * deltaTime; // Increased speed
                }
            }

            // Boss object
            const Boss = {
                x: baseWidth,
                y: baseHeight / 2 - 50,
                width: 100,
                height: 100,
                health: 200,
                maxHealth: 200,
                moveAmplitude: 100,
                moveSpeed: 0.02,
                moveAngle: 0,
                initialY: 0,
                attackPhase: 'idle', // 'idle', 'attacking', 'returning'
                attackSpeed: 100, // Speed of the boss during the attack
                initialX: baseWidth,
                nextHealthThreshold: 200, // Track health thresholds for attack

                draw() {
                    ctx.fillStyle = "red";
                    ctx.fillRect(scale(this.x), scale(this.y), scale(this.width), scale(this.height));

                    // Draw health bar
                    ctx.fillStyle = "green";
                    const healthBarWidth = (this.width * this.health) / this.maxHealth;
                    ctx.fillRect(scale(this.x), scale(this.y - 20), scale(healthBarWidth), scale(10));
                },

                update(deltaTime) {
                    // Check if health has crossed a threshold
                    if (this.attackPhase === 'idle') {
                        // Regular movement
                        if (this.x > baseWidth - 150) {
                            this.x -= 100 * deltaTime; // Move boss towards center
                        } else {
                            this.moveAngle += this.moveSpeed;
                            this.y = this.initialY + Math.sin(this.moveAngle) * this.moveAmplitude;
                        }

                        // Check if it's time to attack based on health
                        if (this.health <= this.nextHealthThreshold) {
                            this.attackPhase = 'attacking';
                        }
                    }
                    if (this.attackPhase === 'attacking') {
                        // Move horizontally towards x = 0
                        if (this.x > 0) {
                            this.x -= this.attackSpeed * deltaTime;
                        } else {
                            this.attackPhase = 'returning';
                            this.nextHealthThreshold -= 50; // Track health after attack
                        }
                    }
                     if (this.attackPhase === 'returning') {
                        // Move back to original position
                        if (this.x < this.originalX) {
                            this.x += this.attackSpeed * deltaTime;
                        } else {
                            this.attackPhase = 'idle';
                        }
                    }
                },

                reset() {
                    this.x = baseWidth;
                    this.y = baseHeight / 2 - 50;
                    this.health = this.maxHealth;
                    this.moveAngle = 0;
                    this.initialY = this.y;
                    this.originalX = baseWidth;
                    this.attackPhase = 'idle';
                    this.nextHealthThreshold = this.maxHealth - 50;
                }
            };


            // Laser object
            class Laser {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.width = 20;
                    this.height = 5;
                    this.speed = 500; // Increased speed
                    this.damage = 10;
                }

                draw() {
                    ctx.fillStyle = "blue";
                    ctx.fillRect(scale(this.x), scale(this.y), scale(this.width), scale(this.height));
                }

                update(deltaTime) {
                    this.x += this.speed * deltaTime;
                }
            }

            // Game initialization
            function init() {
                resizeCanvas();
                window.addEventListener("resize", resizeCanvas);
                bird = Object.create(Bird);
                pipes = [];
                lasers = [];
                score = 0;
                frames = 0;
                boss = null;
                lastFrameTime = performance.now();

                // Handle input for both keyboard and touch events
                function handleInput(e) {
                    e.preventDefault();

                    if (!gameLoop) {
                        startGame();
                    }

                    bird.jump();

                    if (boss) {
                        bird.shoot();
                    }
                }

                // Event listener for keyboard (desktop)
                document.addEventListener("keydown", (e) => {
                    if (e.code === "Space") {
                        handleInput(e);
                    }
                });

                // Event listener for touch (mobile)
                canvas.addEventListener("touchstart", handleInput);
                canvas.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
            }

            // Game update function
            function update(timestamp) {
                const deltaTime = (timestamp - lastFrameTime) / 1000; // Time in seconds
                lastFrameTime = timestamp;

                frames++;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Update and draw bird
                bird.update(deltaTime);
                bird.draw();

                // Update and draw pipes
                if (score < SCORE_TO_BOSS && frames % 150 === 0) {
                    pipes.push(new Pipe());
                }
                pipes.forEach((pipe, index) => {
                    pipe.update(deltaTime);
                    pipe.draw();
                    if (pipe.x + pipe.width < 0) {
                        pipes.splice(index, 1);
                        score++;
                    }

                    if (
                        bird.x < pipe.x + pipe.width &&
                        bird.x + bird.width > pipe.x &&
                        (bird.y < pipe.topHeight || bird.y + bird.height > pipe.bottomY)
                    ) {
                        gameOver();
                    }
                });

                // Boss fight
                if (score >= SCORE_TO_BOSS && !boss) {
                    boss = Object.create(Boss);
                    boss.reset();
                }
                if (boss) {
                    boss.update(deltaTime);
                    boss.draw();

                    // Update and draw lasers
                    lasers.forEach((laser, index) => {
                        laser.update(deltaTime);
                        laser.draw();
                        if (laser.x > baseWidth) {
                            lasers.splice(index, 1);
                        }

                        // Check for collision with boss
                        if (
                            laser.x < boss.x + boss.width &&
                            laser.x + laser.width > boss.x &&
                            laser.y < boss.y + boss.height &&
                            laser.y + laser.height > boss.y
                        ) {
                            boss.health -= laser.damage;
                            lasers.splice(index, 1);
                        }
                    });

                    // Check if boss is defeated
                    if (boss.health <= 0) {
                        gameWin();
                    }
                }

                // Draw score
                ctx.fillStyle = "black";
                ctx.font = `${24}px Arial`;
                ctx.fillText(`Score: ${score}`, 10, 30);
                if (boss) {
                    ctx.fillText(`Health: ${boss.health}`, canvas.width - 140, 30);
                }

                // Check for game over
                if (bird.y + bird.height > canvas.height || bird.y < 0) {
                    gameOver();
                }

                // Request next frame
                if (gameLoop) {
                    requestAnimationFrame(update);
                }
            }

            function gameOver() {
                // gameLoop = null;
                // ctx.fillStyle = "black";
                // ctx.font = `${48}px Arial`;
                // ctx.fillText("Game Over!", canvas.width / 2 - 100, canvas.height / 2);
                // ctx.font = `${24}px Arial`;
                // ctx.fillText("Tap or press Space to restart", canvas.width / 2 - 120, canvas.height / 2 + 40);
            }

            function gameWin() {
                gameLoop = null;
                ctx.fillStyle = "black";
                ctx.font = `${48}px Arial`;
                ctx.fillText("You Win!", canvas.width / 2 - 70, canvas.height / 2);
                ctx.font = `${24}px Arial`;
                ctx.fillText("Tap or press Space to restart", canvas.width / 2 - 100, canvas.height / 2 + 40);
            }

            function startGame() {
                if (!gameLoop) {
                    init();
                    gameLoop = requestAnimationFrame(update);
                }
            }

            function drawInitialScreen() {
                ctx.fillStyle = "black";
                ctx.font = "48px Arial";
                ctx.fillText("Flappy Bird", canvas.width / 2 - 100, canvas.height / 2);
                ctx.font = "24px Arial";
                ctx.fillText("Press Space to start", canvas.width / 2 - 80, canvas.height / 2 + 40);
            }

            // Start by showing initial screen
            resizeCanvas();
            drawInitialScreen();

            // Event listener for starting the game
            document.addEventListener("keydown", (e) => {
                if (e.code === "Space") {
                    startGame();
                }
            });

            canvas.addEventListener("touchstart", () => {
                startGame();
            });
        });
    </script>
</body>
</html>
